\documentclass[12pt,letterpaper]{article}
\usepackage[margin=2.54cm]{geometry}
\usepackage{listings}
\usepackage[dvips,final]{graphicx}
\usepackage{amsmath}
\usepackage{amsthm}
\usepackage{amsfonts}
\usepackage{dsfont}
\usepackage{epsfig}
\usepackage{braket}
\usepackage{mathtools}
\usepackage[shortlabels]{enumitem}
\usepackage{amssymb}
\usepackage{epsf}
\usepackage{epsfig}
\usepackage{ragged2e}
\usepackage{mathrsfs}
\usepackage{color}
\usepackage{appendix}
\usepackage{setspace}
\usepackage{comment}
\usepackage{enumitem}
\usepackage{tcolorbox}
\usepackage{graphicx}
\usepackage{algorithm}
\usepackage{algpseudocode}
\graphicspath{{./images/}}
\usepackage[strings]{underscore}

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\usepackage{tikz}
\usetikzlibrary{shapes.geometric, shapes.misc, arrows, decorations.pathreplacing}
\tikzstyle{startstop} = [rectangle, minimum width=0.4cm, minimum height=0.4cm,text centered, draw=black, fill=red!30]
\tikzstyle{io} = [rectangle, minimum width=1cm, minimum height=0.5cm, text centered, draw=black, fill=blue!20]
\tikzstyle{process} = [rectangle, minimum width=1cm, minimum height=0.5cm, text centered, text width=2.2cm, draw=black, fill=orange!30]
\tikzstyle{blank} = [rectangle, minimum width=0.5cm, minimum height=0.5cm, text width=2.4cm, draw=white, fill=white!30]
\tikzstyle{arrow} = [thick,->,>=stealth]

\tikzstyle{inputOutput} = [rectangle, draw=white, fill=white!30]
\tikzstyle{operator} = [rectangle, draw=black, fill=white!30]
\tikzset{meter/.append style={draw, inner sep=5, rectangle, font=\vphantom{A}, minimum width=20, line width=.5,
 path picture={\draw[black] ([shift={(.1,.15)}]path picture bounding box.south west) to[bend left=60] ([shift={(-.1,.15)}]path picture bounding box.south east);\draw[black,-latex] ([shift={(0,.1)}]path picture bounding box.south) -- ([shift={(.18,-.08)}]path picture bounding box.north);}}}
\tikzset{cross/.style={cross out, draw=black, minimum size=2*(#1-\pgflinewidth), inner sep=0pt, outer sep=0pt},
%default radius will be 1pt.
cross/.default={1pt}}
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

\usepackage{color}
\definecolor{darkblue}{rgb}{0,0,0.5}
\definecolor{darkgreen}{rgb}{0,0.5,0}

\usepackage[
    colorlinks=true,
    linkcolor=darkblue,
    urlcolor=darkblue,
    citecolor=darkgreen
]{hyperref}
\usepackage[noabbrev]{cleveref}

\DeclareMathOperator{\supp}{supp}
\DeclareMathOperator{\pr}{Pr}
\DeclareMathOperator{\tr}{Tr}

\makeatletter
\renewcommand*{\ALG@name}{Protocol}
\makeatother

\newcommand{\abnote}[1]{\textcolor{blue}{[#1]}}
\newcommand{\pynote}[1]{\textcolor{red}{[#1]}}

%%
\makeatletter
\providecommand\theHALG@line{\thealgorithm.\arabic{ALG@line}}
\makeatother
%%


\makeatletter
\newenvironment{breakablealgorithm}
  {% \begin{breakablealgorithm}
   \begin{center}
     \refstepcounter{algorithm}% New algorithm
     \hrule height.8pt depth0pt \kern2pt% \@fs@pre for \@fs@ruled
     \renewcommand{\caption}[2][\relax]{% Make a new \caption
       {\raggedright\textbf{\fname@algorithm~\thealgorithm} ##2\par}%
       \ifx\relax##1\relax % #1 is \relax
         \addcontentsline{loa}{algorithm}{\protect\numberline{\thealgorithm}##2}%
       \else % #1 is not \relax
         \addcontentsline{loa}{algorithm}{\protect\numberline{\thealgorithm}##1}%
       \fi
       \kern2pt\hrule\kern2pt
     }
  }{% \end{breakablealgorithm}
     \kern2pt\hrule\relax% \@fs@post for \@fs@ruled
   \end{center}
  }
\makeatother

\crefname{algorithm}{protocol}{protocols}
\Crefname{algorithm}{Protocol}{Protocols}
\crefname{line}{step}{steps}
\Crefname{line}{Step}{Steps}

\newtheorem{theorem}{Theorem}[section]
\newtheorem{cor}[theorem]{Corollary}
\newtheorem{conj}[theorem]{Conjecture}
\newtheorem{lem}[theorem]{Lemma}
\newtheorem{prop}[theorem]{Proposition}

\theoremstyle{definition}
\newtheorem{defn}[theorem]{Definition}
\newtheorem{example}[theorem]{Example}

\theoremstyle{remark}
\newtheorem{rem}[theorem]{Remark}

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
% comment out for the short version
\newcommand*{\TOGGLE}{}
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

\title{
PKQM}
\author{Anne Broadbent and Peter Yuen\footnote{University of Ottawa, Department of Mathematics and Statistics; \texttt{\{abroadbe,pyuen103\}@uottawa.ca}}}
\date{}

\begin{document}

\maketitle

\section{Preliminaries}

\subsection{Coset states and conjugate coding states}
\label{Coset states and conjugate coding states}
For a linear subspace $A$ of $\mathbb{F}^n_2$ and $s,s' \in \{0,1\}^n$, a subspace state $\ket{A}$ and coset state $\ket{A_{s,s'}}$ is defined as
\begin{equation}
    \ket{A} = \frac{1}{\sqrt{|A|}}\sum_{v\in A} \ket{v} \quad 
    \text{and} \quad \ket{A_{s,s'}} = X^s Z^{s'} \ket{A} = \frac{1}{\sqrt{|A|}} \sum_{v \in A} (-1)^{v \cdot s'} \ket{v+s},
\end{equation}
where $X^s=X^{s_1} \otimes \cdots \otimes X^{s_n}$, $Z^{s'} = Z^{s'_1} \otimes \cdots \otimes Z^{s'_n}$ and
\begin{equation*}
    X =
    \begin{pmatrix}
    0 & 1\\
    1 & 0
    \end{pmatrix}
    \quad \text{ and } \quad
    Z =
    \begin{pmatrix}
    1 & 0\\
    0 & -1
    \end{pmatrix}.
\end{equation*}
The subspace state is a superposition over all the elements in the subspace $A$. In the computational basis, the coset state is a superposition over all elements in the coset $A+s$, while in the Hadamard basis, it is a superposition over all elements in the coset $A^\perp+s'$. 

For $x, \theta \in \{0,1\}^n$, an $n$-tensor product of conjugate coding states is
\begin{equation}
    \ket{x}_{\theta} = \ket{x_1}_{\theta_1} \cdots \ket{x_n}_{\theta_n},
\end{equation}
where $\ket{x_i}_{\theta_i} = H^{\theta_i}\ket{x_i}$ and $H$ is the Hadamard gate.

For the following lemma, let $\mathcal{B}=\{u_1, \ldots, u_n\}$ be a basis of $\mathbb{F}^n_2$ and let $U_\mathcal{B}$ be a unitary of $(\mathbb{C}^2)^{\otimes n}$ which permutes the standard basis vectors:
\begin{equation}
\label{permuteBasis}
    \forall x \in \{0,1\}^n, \quad \quad U_\mathcal{B}\ket{x} = \Ket{\sum_i x_i u_i}.
\end{equation}

\begin{lem}[\cite{CV21arxiv}]
\label{cosetBB84equivalence}
    Let $\{u_1, \ldots, u_n\}$ be a basis of $\mathbb{F}^n_2$ and $U_\mathcal{B}$ be defined as in \cref{permuteBasis}. Let $\{u^1, \ldots, u^n\}$ be its dual basis, \emph{i.e.} $u^i\cdot u_j = \delta_{i,j}$. Let $T \subseteq \{1,\ldots,n\}$ be such that $|T|=n/2$ and $A=\text{Span}\{u_i : i\in \overline{T}\}$. Let $\theta \in \{0,1\}^n$ be the indicator of $\overline{T}$ (\emph{i.e.}, $\theta_i=1$ if and only if $i \notin T$), and $x \in \{0,1\}^n$. Let $s=\sum_{i\in T} x_iu_i$ and $s'=\sum_{i \in \overline{T}}x_iu^i$. Then
    \begin{equation}
        \ket{A_{s,s'}} = U_\mathcal{B} \ket{x}_\theta
    \end{equation}
\end{lem}

Then generating uniformly random conjugate coding states $\ket{x}_\theta$, with $\theta$ having Hamming weight $n/2$, is equivalent to generating a uniformly random coset state $\ket{A_{s,s'}}$ over subspaces $A \subseteq \mathbb{F}^n_2$ with dimension $n/2$, as seen through the following steps:
\begin{enumerate}
    \item Choose $n\geq 2$ to be even. Select a uniformly random basis $\mathcal{B}=\{u_1, \ldots, u_n\}$ of $\mathbb{F}^n_2$.
    \item Set $T = \{i: \theta_i = 0\}$ and then set $A=\text{Span}\{u_i: \theta_i=1\}=\text{Span}\{u_i: i \in \overline{T}\}$. Then $A$ is a uniformly random subspace of $\mathbb{F}^n_2$ of dimension $n/2$. \label{generateSubspace}
    \item Set $s=\sum_{i\in T} x_iu_i$ and $s'=\sum_{i\in \overline{T}}x_iu^i$. \label{generateParameters}
    \item By \Cref{cosetBB84equivalence}, applying $U_{\mathcal{B}}$ to $\ket{x}_\theta$ yields $\ket{A_{s,s'}}$.
\end{enumerate}

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

\subsection{Obfuscation}

\begin{defn}[\cite{Zha19}]
A \emph{subspace hiding obfuscator} (\textsf{shO}) for a field $\mathbb{F}$ and dimensions $d_0,d_1$ is a PPT algorithm \textsf{shO} such that:
\begin{itemize}
    \item \textbf{Input:} \textsf{shO} takes as input the description of a linear subspace $A \subseteq \mathbb{F}^n$ of dimension ${d \in \{d_0,d_1\}}$. For concreteness, we will assume $A$ is given as a matrix whose rows form a basis for $A$.
    \item \textbf{Output:} \textsf{shO} outputs a circuit $\hat{A}$ that computes membership in $A$. Precisely, let $A(x)$ be the function that decides membership in $A$. Then there exists a negligible function $\textsf{negl}$ such that,
    \begin{equation*}
        \Pr[\hat{A}(x)=A(x), \, \forall x: \hat{A} \leftarrow \textsf{shO}(A)] \geq 1-\textsf{negl}(n)
    \end{equation*}
    \item \textbf{Security:} For security, consider the following game between an adversary and a challenger, indexed by a bit $b$.
    \begin{itemize}
        \item The adversary submits to the challenger a subspace $A_0$ of dimension $d_0$.
        \item The challenger samples a uniformly random subspace $A_1 \subseteq \mathbb{F}^n$ of dimension $d_1$ such that $A_0 \subseteq A_1$. It then runs $\hat{A} \leftarrow \textsf{shO}(A_b)$, and gives $\hat{A}$ to the adversary.
        \item The adversary makes a guess $b'$ for $b$.
    \end{itemize}
    The adversary's advantage is the probability $b'=b$, minus 1/2. \textsf{shO} is secure if all PPT adversaries have negligible advantage.
\end{itemize}
\end{defn}

\pynote{
Question: Does using post-quantum iO (secure against QPT adversaries) in \Cref{shOconstruction} immediately imply post-quantum \textsf{shO}? 
}

\pynote{
Origin of question: \cite{Zha19} (and all other versions I'm aware of) only mention PPT adversaries in the definitions of \textsf{iO} and \textsf{shO}. But, in the longer version of \cite{CLLZ21} (the arXiv version), the authors cite \cite{Zha19} for the definition of \textsf{shO} and \Cref{shOconstruction}, but in their restatement of the definition of \textsf{shO}, QPT adversaries are mentioned in place of PPT adversaries. However, unlike \cite{Zha19}, their definition of \textsf{iO} mentions QPT adversaries as well.}

Note that we will sometimes use $\textsf{shO}_A()$ instead of $\hat{A}$ to denote the program $\textsf{shO}(A)$. With this notation, $\textsf{shO}_A(\cdot - s)$ denotes the program which, on input $x$, runs the program $\textsf{shO}_A()$ on input $x-s$.

\begin{theorem}[\cite{Zha19}]
\label{shOconstruction}
    If injective one-way functions exist, then any indistinguishably obfuscator, appropriately padded, is also a subspace hiding obfuscator for a field $\mathbb{F}$ and dimenions $d_1,d_1$, as long as $|\mathbb{F}|^{n-d_1}$ is exponential.
\end{theorem}

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

\subsection{Quantum Money}

In \cite{AC12}, Aaronson and Christiano introduced a simpler primitive called public-key quantum money \emph{mini-schemes}. They then showed how to combine a secure mini-scheme with a digital signature scheme to create a secure public-key quantum money scheme. Given this, we shall only consider mini-schemes and often refer to such schemes as quantum money schemes. We follow the modified definition of a quantum money mini-scheme given in \cite{Zha19}, which is equivalent to the original definition in \cite{AC12}.

\begin{defn}
A quantum money \emph{mini-scheme} consists of two quantum polynomial time algorithms:
\begin{itemize}
    \item \textsf{Gen}, takes as input the security parameter $1^\lambda$ and samples a banknote $\ket{\$}$.
    \item \textsf{Ver}, takes an alleged banknote and either accepts or rejects, and if accepted, produces a classical \emph{serial number} $s$ for the note.
\end{itemize}

For \emph{correctness}, \textsf{Ver} should always accept banknotes produced by $\textsf{Gen}$. To ensure that the serial number is essentially a deterministic function of the money:
\begin{itemize}
    \item For a money state $\ket{\$}$, let $H_{\infty}(\ket{\$})=-\log \text{min}_s \Pr[\textsf{Ver}(\ket{\$})=s]$ be the min-entropy of $s$ produced by applying $\textsf{Ver}$ to $\ket{\$}$, where rejecting the output does not count as contributing to the min-entropy. It is then required that $\mathbb{E}[H_{\infty}(\ket{\$})]$, the expectation over $\ket{\$}\leftarrow \textsf{Gen}(1^\lambda)$, is negligible.
\end{itemize}
To ensure that $\textsf{Ver}$ does not perturb the money:
\begin{itemize}
    \item For a money state $\ket{\$}$, let $\ket{\psi}$ be the state after running $\textsf{Ver}(\ket{\$})$. We require that $\mathbb{E}[|\braket{\psi|\$}|^2]\geq1-\textsf{negl}(\lambda)$, where the expectation is over $\ket{\$}\leftarrow \textsf{Gen}(1^\lambda)$.
\end{itemize}
\pynote{Add remark from \cite{Zha19} about how it is sufficient to only consider the first of the above two points}
For security, we consider the following game between an adversary $A$ and a challenger:
\begin{itemize}
    \item The challenger runs $\textsf{Gen}(1^\lambda)$ to produce a banknote $\ket{\$}$. It runs $\textsf{Ver}$ on the banknote to extract a serial number $s$.
    \item The challenger sends $\ket{\$}$ to $A$.
    \item The adversary $A$ produces two candidate quantum money states $\ket{\$_0}$, $\ket{\$_1}$, which are potentially entangled.
    \item The challenger runs $\textsf{Ver}$ on both states to get two serial numbers $s_0, s_1$.
    \item The challenger accepts if and only if both runs of $\textsf{Ver}$ pass, and the serial numbers satisfy $s_0=s_1=s$.
\end{itemize}
A quantum money mini-scheme is \emph{secure} if, for all QPT adversaries $A$, the probability that the challenger accepts in the above game is negligible.
\end{defn}

In \cite{Zha19}, Zhandry instantiates Aaaronson and Christiano's \cite{AC12} construction of public key quantum money with a subspace hiding obfuscator. This scheme is given below.

\paragraph{Generating banknotes:} Let $\mathbb{F}=\mathbb{Z}_q$ for some prime $q$. Let $\lambda$ be the security parameter. To generate a banknote, choose $n$ to be a random even integer that is sufficiently large; $n$ will be chosen later but it will depend on $q$ and $\lambda$. Choose a random subspace $A \subseteq \mathbb{F}^n$ of dimension $n/2$. Let $A^{\perp}=\{w: w\cdot v=0, \, \forall v \in A\}$ be the dual space to $A$.

Let $\ket{\$_A}=\frac{1}{|\mathbb{F}|^{n/4}}\sum_{v \in A} \ket{v}$. Let $P_0 = \textsf{shO}(A)$ and $P_1 = \textsf{shO}(A^{\perp})$. Output $(\ket{\$_A}, P_0, P_1)$ as the quantum money state.

\paragraph{Verifying banknotes:} Given a banknote state, first measure the program registers, obtaining $P_0, P_1$. These will be the serial number. Let $\ket{\$}$ be the remaining registers. 
Now run $P_0$ in superposition and measure the result. If $P_0$ outputs 0, reject. Otherwise, continue. Note that if $\ket{\$}$ is the honest banknote state $\ket{\$_A}$ and $P_0$ is the obfuscation of $A$, then $P_0$ will output 1 with certainty.

Next, apply the quantum Fourier transform to $\ket{\$}$. Note that if $\ket{\$}=\ket{\$_A}$, then the resultant state is $\ket{\$_{A^\perp}}$.

Now apply $P_1$ in superposition and measure the result. Again, in the case of an honest banknote, the result is 1 with certainty.

Finally, apply the inverse quantum Fourier transform. In the case of an honest banknote, the state goes back to being exactly $\ket{\$_A}$.

\paragraph{}
For security of the above scheme, we have:

\begin{theorem}[\cite{Zha19}]
    If \textsf{shO} is a secure subspace-hiding obfuscator for $d_0=n/2$ and some $d_1$ such that both $|\mathbb{F}|^{n-d_1}$ and $|\mathbb{F}|^{d_1-n/2}$ are exponentially-large, then the construction above is a secure quantum money scheme.
\end{theorem}

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

\section{PKQM using conjugate coding states}

\subsection{Without noise tolerance}

\paragraph{Generating banknotes:} Let $\mathbb{F}=\mathbb{Z}_2$. Let $\lambda$ be the security parameter. To generate a banknote, choose $n$ to be a random even integer that is sufficiently large; $n$ will be chosen later but it will depend on $q=2$ and $\lambda$. Choose a uniformly random $x \in \{0,1\}^n$ and a random $\theta \in \{0,1\}^n$ such that the Hamming weight of $\theta$ is $n/2$. Choose a uniformly random basis $\mathcal{B}=\{u_1, \ldots, u_n\}$ of $\mathbb{F}^n_2$.

Define $U_\mathcal{B}$ as in \cref{permuteBasis}. Define $A$ as in step \eqref{generateSubspace}. Define $s$ and $s'$ as in step \eqref{generateParameters}.

Let $P_0 = \textsf{shO}_A(\cdot -s)$ and $P_1 = \textsf{shO}_{A^\perp}(\cdot - s')$. Output $(\ket{x}_{\theta}, U_\mathcal{B}, P_0, P_1)$ as the quantum money state.

\paragraph{Verifying banknotes:} Given a banknote state, first measure the program registers, obtaining $U_\mathcal{B}, P_0, P_1$. These will be the serial number. Let $\ket{\$}$ be the remaining registers.

Now, apply $U_\mathcal{B}$ and run $P_0$ in superposition and measure the result. If $P_0$ outputs 0, reject. Otherwise, continue. Note that if $\ket{\$}$ is the honest banknote state $\ket{x}_{\theta}$ and $P_0$ is the obfuscation of $A$, then $U_{\mathcal{B}}\ket{\$}=\ket{A_{s,s'}}$ and so $P_0$ will output 1 with certainty.

Next, apply $H^{\otimes n}$, which is the quantum Fourier transform for $\mathbb{F}^n_2$, to $\ket{\$}$. Note that if $\ket{\$}=\ket{x}_\theta$, then the resultant state is $\ket{A^{\perp}_{s',s}}$.

Now apply $P_1$ in superposition and measure the result. Again, in the case of an honest banknote, the result is 1 with certainty.

Finally, apply $H^{\otimes n}$ followed by $U^*_{\mathcal{B}}$. In the case of an honest banknote, the state goes back to being exactly $\ket{x}_\theta$.

\subsection{With noise tolerance}

\paragraph{Idea:}
\begin{enumerate}
    \item Define the notion of a \emph{noisy subspace hiding obfuscator}.
    \item Construct a noisy subspace hiding obfuscator from iO (perhaps take inspiration from the proof of \Cref{shOconstruction}).
\end{enumerate}

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

\subsubsection{The effect of errors}
Before defining the notion of a noisy subspace hiding obfuscator, we observe how errors on conjugate coding states affects the corresponding coset state through the relation $U_{\mathcal{B}}\ket{x}_\theta=\ket{A_{s,s'}}$ outlined in \Cref{Coset states and conjugate coding states}.

First, we recall from \cite{CV21arxiv} that for any $x,x' \in \{0,1\}^n$,
\begin{equation}
\label{permuteBasisEffect}
    U_{\mathcal{B}} X^x U^*_{\mathcal{B}} = X^t \quad \text{ and } \quad U_{\mathcal{B}} Z^{x'} U^*_{\mathcal{B}} = Z^{t'},
\end{equation}
where $x=\sum_i x_i u_i$ and $t'= \sum_i x'_i u^i$.

We also recall the observation that
\begin{equation*}
    \ket{x}_\theta = X^{x_T} \ket{x_{\overline{T}}}_{\theta} = X^{x_T} Z^{x_{\overline{T}}} \ket{0}_\theta.
\end{equation*}

Now, let $e$ be an $n$-bit vector with 1's wherever a bit-flip error has occurred on the state $\ket{x}_\theta$. Similarly, let $e'$ be an $n$-bit vector with 1's in each place where a phase-flip error has occurred. Then the effect of the error $X^e$ is
\begin{align*}
    U_{\mathcal{B}} X^e \ket{x}_\theta &= U_{\mathcal{B}} X^e X^{x_T} Z^{x_{\overline{T}}} \ket{0}_\theta\\
    &= X^{t_e + s} Z^{s'} \ket{A}\\
    &= \ket{A_{s+t_e,s'}}
\end{align*}
where $t_e = \sum_i e_i u_i$. The effect of the error $Z^{e'}$ is
\begin{align*}
    U_{\mathcal{B}} Z^{e'} \ket{x}_\theta &= U_{\mathcal{B}} Z^{e'} X^{x_T} Z^{x_{\overline{T}}} \ket{0}_\theta\\
    &= (-1)^{x_T \cdot e'}U_{\mathcal{B}}X^{x_T}Z^{e'}Z^{x_{\overline{T}}}\ket{x}_\theta\\
    &= (-1)^{s \cdot t_{e'}} X^{s} Z^{t_{e'}+s'} \ket{A}\\
    &= (-1)^{s \cdot t_{e'}} \ket{A_{s,s'+t_{e'}}}
\end{align*}
where $t_{e'}=\sum_i e'_i u^i$.

Assuming we knew exactly what the error vectors $e$ and $e'$ were (and hence what $t_e$ and $t_{e'}$ were), we could use $P_0=\textsf{shO}_A(\cdot-s-t_e)$ and $P_1 = \textsf{shO}_{A^\perp}(\cdot-s'-t_{e'})$ to accept the noise-affected money state. There are $2^{2n}$ possible choices for $(t_e,t_{e'})$, though our noisy subspace hiding obfuscator should not accept the state for every pair $(t_e,t_{e'})$. We expect there to be a threshold for how much noise we are willing to tolerate.

Alternatively, we could consider a set of errors $E$. For example, $E$ could consist of all vectors $t_e$ that represent a bit-flip error on a single qubit. Then we could define a union of cosets $A_E$ in the following way,
\begin{equation*}
    A_E \coloneqq \bigcup_{t_e \in E} \{A+t_e\}.
\end{equation*}
Then instead of checking $\textsf{shO}(\cdot-s-t_e)$ for each $t_e \in E$, we could define a \emph{noisy} version of \textsf{shO} which, on input $x$, would check membership of $x-s$ in $A_E$.

\begin{defn}
A \emph{noisy subspace hiding obfuscator} (\textsf{nshO}) for a field $\mathbb{F}$ and dimensions $d_0,d_1$ is a PPT algorithm \textsf{nshO} such that:
\begin{itemize}
    \item \textbf{Input:} \textsf{nshO} takes as input the description of a linear subspace $A \subseteq \mathbb{F}^n$ of dimension $d \in \{d_0,d_1\}$, and a subset $E \subseteq \mathbb{F}^n$. For concreteness, we will assume $A$ is given as a matrix whose rows form a basis for $A$.
    \item \textbf{Output:} \textsf{nshO} outputs a circuit $\hat{A}_E$ that computes membership in 
    \begin{equation*}
        A_E \coloneqq \bigcup_{t_e \in E} \{A+t_e\}.
    \end{equation*}
    Precisely, let $A_E(x)$ be the function that decides membership in $A_E$. Then there exists a negligible function $\textsf{negl}$ such that,
    \begin{equation*}
        \Pr[\hat{A}_E(x)=A_E(x), \, \forall x: \hat{A}_E \leftarrow \textsf{nshO}(A,E)] \geq 1-\textsf{negl}(n)
    \end{equation*}
    \item \textbf{Security:} For security, consider the following game between an adversary and a challenger, indexed by a bit $b$.
    \begin{itemize}
        \item The adversary submits to the challenger a subspace $A_0$ and of dimension $d_0$, and a set $E$.
        \item The challenger samples a uniformly random subspace $A_1 \subseteq \mathbb{F}^n$ of dimension $d_1$ such that $A_0 \subseteq A_1$. It then runs $\hat{A}_E \leftarrow \textsf{shO}(A_b, E)$, and gives $\hat{A}_E$ to the adversary.
        \item The adversary makes a guess $b'$ for $b$.
    \end{itemize}
    The adversary's advantage is the probability $b'=b$, minus 1/2. \textsf{nshO} is secure if all QPT adversaries have negligible advantage.
\end{itemize}
\end{defn}

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

\bibliographystyle{bibtex/bst/alphaarxiv.bst}
\bibliography{bibtex/bib/full.bib,bibtex/bib/quantum.bib}

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\end{document}
